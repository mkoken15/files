<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Gestionnaire de Fichiers Local</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary: #1a3c34;
      --primary-dark: #0f2b24;
      --secondary: #2e6b5e;
      --background: #f7f9fc;
      --card-bg: #ffffff;
      --text: #2d3748;
      --error: #e53e3e;
      --shadow: 0 4px 20px rgba(0,0,0,0.1);
      --border-radius: 12px;
    }
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: 'Inter', sans-serif;
      background: var(--background);
      color: var(--text);
      padding: 20px;
      line-height: 1.5;
    }
    h1, h2 {
      font-weight: 600;
      color: var(--primary);
      margin-bottom: 15px;
    }
    h1 {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 1.8rem;
    }
    .section {
      background: var(--card-bg);
      padding: 20px;
      border-radius: var(--border-radius);
      box-shadow: var(--shadow);
      margin-bottom: 20px;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    .section:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 24px rgba(0,0,0,0.15);
    }
    input, select, button {
      padding: 12px;
      margin: 8px 4px;
      border-radius: 8px;
      border: 1px solid #e2e8f0;
      font-size: 1rem;
      font-family: 'Inter', sans-serif;
      transition: border-color 0.3s ease, box-shadow 0.3s ease;
    }
    input:focus, select:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 8px rgba(26, 60, 52, 0.2);
    }
    button {
      background: var(--primary);
      color: white;
      border: none;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: background 0.3s ease, transform 0.2s ease;
    }
    button:hover {
      background: var(--secondary);
      transform: translateY(-2px);
    }
    button:active {
      transform: translateY(0);
    }
    .folder-list {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      gap: 16px;
    }
    .folder-item {
      background: #edf2f7;
      padding: 15px;
      border-radius: 10px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: all 0.3s ease;
    }
    .folder-item:hover {
      background: #e2e8f0;
      transform: translateY(-2px);
    }
    .folder-item.active {
      background: var(--primary);
      color: white;
    }
    .preview {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: 16px;
      margin-top: 15px;
    }
    .preview img, .preview canvas, .preview .video-placeholder {
      width: 100%;
      max-height: 140px;
      object-fit: cover;
      border-radius: 10px;
      cursor: pointer;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    .preview .video-placeholder {
      background: #1a202c;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 0.9rem;
      text-align: center;
      padding: 10px;
    }
    .preview img:hover, .preview canvas:hover, .preview .video-placeholder:hover {
      transform: scale(1.05);
      box-shadow: var(--shadow);
    }
    .file-actions button {
      background: var(--error);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 0.9rem;
    }
    .file-actions button:hover {
      background: #c53030;
    }
    #fullscreenViewer {
      position: fixed;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.95);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      cursor: default;
    }
    #fullscreenViewer img, #fullscreenViewer .video-player {
      max-width: 90vw;
      max-height: 90vh;
      border-radius: 10px;
      box-shadow: 0 0 20px rgba(255,255,255,0.3);
    }
    .close-button {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0,0,0,0.7);
      color: white;
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: background 0.3s ease;
    }
    .close-button:hover {
      background: var(--error);
    }
    .nav-arrows {
      position: absolute;
      top: 50%;
      width: 100%;
      display: flex;
      justify-content: space-between;
      padding: 0 20px;
      transform: translateY(-50%);
    }
    .nav-arrows button {
      background: rgba(0,0,0,0.7);
      color: white;
      border: none;
      font-size: 2rem;
      padding: 10px;
      cursor: pointer;
      border-radius: 50%;
    }
    .nav-arrows button:hover {
      background: var(--primary);
    }
    .loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 12px 24px;
      border-radius: 8px;
      display: none;
      z-index: 10001;
      font-size: 1rem;
    }
    .toast {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: var(--error);
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      box-shadow: var(--shadow);
      display: none;
      z-index: 10002;
      animation: slideIn 0.3s ease, slideOut 0.3s ease 2.7s forwards;
    }
    @keyframes slideIn {
      from { transform: translateY(100px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    @keyframes slideOut {
      from { transform: translateY(0); opacity: 1; }
      to { transform: translateY(100px); opacity: 0; }
    }
    .video-player {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .video-player video {
      width: 100%;
      max-height: 80vh;
      border-radius: 10px;
    }
    .video-controls {
      position: absolute;
      bottom: 15px;
      width: 90%;
      background: rgba(0,0,0,0.8);
      padding: 10px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      gap: 12px;
      color: white;
      box-shadow: var(--shadow);
    }
    .video-controls button {
      background: none;
      color: white;
      font-size: 1.3rem;
      padding: 5px;
    }
    .video-controls input[type="range"] {
      width: 100%;
      max-width: 250px;
      cursor: pointer;
    }
    .video-controls select {
      background: var(--primary);
      color: white;
      border: none;
      padding: 8px;
      border-radius: 6px;
    }
    .pagination {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-top: 20px;
    }
    .pagination button {
      padding: 10px 20px;
      font-size: 1rem;
    }
    @media (max-width: 600px) {
      .folder-list {
        grid-template-columns: 1fr;
      }
      .preview {
        grid-template-columns: 1fr;
      }
      .preview img, .preview canvas, .preview .video-placeholder {
        max-height: 180px;
      }
      input, select, button {
        width: 100%;
        padding: 14px;
        font-size: 1.1rem;
      }
      h1 {
        font-size: 1.5rem;
      }
      h2 {
        font-size: 1.2rem;
      }
      .folder-item {
        padding: 12px;
      }
      .video-controls {
        flex-wrap: wrap;
        gap: 8px;
      }
      .video-controls input[type="range"] {
        max-width: 100%;
      }
      .close-button {
        top: 15px;
        right: 15px;
        width: 36px;
        height: 36px;
      }
    }
  </style>
</head>
<body>
  <h1><span class="material-icons">folder</span> Gestionnaire de Fichiers</h1>
  <div class="section">
    <h2>Créer un dossier</h2>
    <input type="text" id="folderName" placeholder="Nom du dossier" aria-label="Nom du dossier" />
    <button onclick="createFolder()"><span class="material-icons">create_new_folder</span> Créer</button>
  </div>
  <div class="section">
    <h2>Ajouter des fichiers</h2>
    <select id="folderSelect" aria-label="Sélectionner un dossier">
      <option disabled selected>-- Choisir un dossier --</option>
    </select>
    <input type="file" id="fileInput" multiple accept="image/*,video/*" aria-label="Ajouter des fichiers" />
    <label for="sortSelect">Trier :</label>
    <select id="sortSelect" onchange="loadFolders()" aria-label="Trier les fichiers">
      <option value="alpha">Ordre alphabétique</option>
      <option value="recent">Récent</option>
    </select>
    <button onclick="addFiles()"><span class="material-icons">upload_file</span> Ajouter</button>
    <button onclick="exportData()"><span class="material-icons">download</span> Exporter</button>
    <input type="file" id="importInput" accept=".json" style="display: none;" aria-label="Importer un fichier JSON" />
    <button onclick="document.getElementById('importInput').click()"><span class="material-icons">upload</span> Importer</button>
  </div>
  <div class="section">
    <h2>Dossiers</h2>
    <button id="backButton" style="display: none;" onclick="goBack()"><span class="material-icons">arrow_back</span> Retour</button>
    <div id="foldersContainer" class="folder-list"></div>
    <div id="filesContainer" class="preview"></div>
    <div id="pagination" class="pagination"></div>
  </div>
  <div id="fullscreenViewer"></div>
  <div id="loading" class="loading">Chargement...</div>
  <div id="toast" class="toast"></div>
  <script>
    const DB_NAME = "FileManagerDB";
    const DB_VERSION = 2; // Incremented for index addition
    const STORE_NAME = "files";
    const THUMBNAIL_STORE = "thumbnails";
    let db;
    let currentFolder = null;
    let currentFiles = [];
    let currentFileIndex = -1;
    let currentPage = 1;
    const ITEMS_PER_PAGE = 10;
    const MAX_THUMBNAIL_SIZE = 10 * 1024 * 1024; // 10 MB

    function showToast(message) {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.style.display = 'block';
      setTimeout(() => { toast.style.display = 'none'; }, 3000);
    }

    function showLoading(show) {
      document.getElementById('loading').style.display = show ? 'block' : 'none';
    }

    function openDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        request.onerror = () => {
          console.error("Erreur d'accès à IndexedDB");
          showToast("Erreur d'accès à la base de données.");
          reject(new Error("Erreur d'accès à IndexedDB"));
        };
        request.onupgradeneeded = (event) => {
          db = event.target.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            const store = db.createObjectStore(STORE_NAME, { keyPath: "id", autoIncrement: true });
            store.createIndex("folder", "folder", { unique: false });
          }
          if (!db.objectStoreNames.contains(THUMBNAIL_STORE)) {
            db.createObjectStore(THUMBNAIL_STORE, { keyPath: "id" });
          }
        };
        request.onsuccess = (event) => {
          db = event.target.result;
          console.log("Base de données ouverte");
          resolve();
        };
      });
    }

    function saveThumbnail(id, thumbnailData) {
      return new Promise((resolve, reject) => {
        const tx = db.transaction(THUMBNAIL_STORE, "readwrite");
        const store = tx.objectStore(THUMBNAIL_STORE);
        store.put({ id, data: thumbnailData }).onsuccess = resolve;
        store.onerror = () => reject(new Error("Erreur lors de l'enregistrement de la miniature"));
      });
    }

    function getThumbnail(id) {
      return new Promise((resolve) => {
        const tx = db.transaction(THUMBNAIL_STORE, "readonly");
        const store = tx.objectStore(THUMBNAIL_STORE);
        const request = store.get(id);
        request.onsuccess = () => resolve(request.result ? request.result.data : null);
        request.onerror = () => resolve(null);
      });
    }

    function saveFile(folder, file, dataURL) {
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE_NAME, "readwrite");
        const store = tx.objectStore(STORE_NAME);
        const fileRecord = {
          folder,
          name: file.name,
          type: file.type || "unknown",
          data: dataURL,
          size: file.size,
          created: Date.now()
        };
        const request = store.add(fileRecord);
        request.onsuccess = (event) => {
          console.log(`Fichier ${file.name} ajouté, ID: ${event.target.result}`);
          resolve(event.target.result);
        };
        request.onerror = () => {
          console.error(`Erreur lors de l'ajout de ${file.name}`);
          reject(new Error(`Erreur lors de l'ajout de ${file.name}`));
        };
      });
    }

    async function loadFolders() {
      try {
        showLoading(true);
        const tx = db.transaction(STORE_NAME, "readonly");
        const store = tx.objectStore(STORE_NAME);
        const request = store.getAll();
        const data = await new Promise((resolve, reject) => {
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(new Error("Erreur lors du chargement des dossiers"));
        });
        const foldersMap = {};
        data.filter(file => file.folder && file.data && !file.name.startsWith('placeholder_')).forEach(file => {
          if (!foldersMap[file.folder]) foldersMap[file.folder] = [];
          foldersMap[file.folder].push(file);
        });
        const sortMethod = document.getElementById('sortSelect').value;
        renderFolders(foldersMap, sortMethod);
        updateFolderSelect(Object.keys(foldersMap));
        if (currentFolder) await showFolderFiles(currentFolder, sortMethod);
        showLoading(false);
        if (Object.keys(foldersMap).length === 0) {
          document.getElementById('foldersContainer').innerHTML = "<p>Aucun dossier trouvé. Créez un dossier pour commencer !</p>";
        }
      } catch (err) {
        console.error("Erreur dans loadFolders:", err);
        showToast("Erreur lors du chargement des dossiers.");
        showLoading(false);
      }
    }

    function renderFolders(foldersMap, sortMethod) {
      const container = document.getElementById("foldersContainer");
      const fragment = document.createDocumentFragment();
      let folders = Object.keys(foldersMap);
      if (sortMethod === 'recent') {
        folders.sort((a, b) => {
          const latestA = Math.max(...foldersMap[a].map(f => f.created || 0));
          const latestB = Math.max(...foldersMap[b].map(f => f.created || 0));
          return latestB - latestA;
        });
      } else {
        folders.sort((a, b) => a.localeCompare(b, ['fr', 'tr'], { sensitivity: 'accent', ignorePunctuation: true }));
      }
      folders.forEach(folder => {
        const div = document.createElement("div");
        div.className = `folder-item ${folder === currentFolder ? 'active' : ''}`;
        div.innerHTML = `<span class="material-icons">folder</span> ${folder}`;
        div.onclick = () => {
          currentFolder = folder;
          currentPage = 1;
          showFolderFiles(folder, sortMethod);
          document.getElementById('backButton').style.display = 'inline-flex';
        };
        fragment.appendChild(div);
      });
      container.innerHTML = "";
      fragment.appendChild(container);
      if (!currentFolder) {
        document.getElementById("filesContainer").innerHTML = "";
        document.getElementById('backButton').style.display = 'none';
        document.getElementById('pagination').innerHTML = "";
      }
    }

    async function showFolderFiles(folder, sortMethod) {
      try {
        showLoading(true);
        const tx = db.transaction(STORE_NAME, "readonly");
        const index = tx.objectStore(STORE_NAME).index("folder");
        const request = index.getAll(folder);
        currentFiles = await new Promise((resolve, reject) => {
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(new Error(`Erreur lors du chargement des fichiers pour ${folder}`));
        });
        currentFiles = currentFiles.filter(file => file.data && !file.name.startsWith('placeholder_'));
        if (sortMethod === 'recent') {
          currentFiles.sort((a, b) => (b.created || 0) - (a.created || 0));
        } else {
          currentFiles.sort((a, b) => (a.name || "").localeCompare(b.name || "", ['fr', 'tr'], { sensitivity: 'accent', ignorePunctuation: true }));
        }
        renderFiles(currentFiles, folder);
        renderPagination(currentFiles.length);
        showLoading(false);
      } catch (err) {
        console.error("Erreur dans showFolderFiles:", err);
        showToast("Erreur lors du chargement des fichiers.");
        showLoading(false);
      }
    }

    function renderPagination(totalItems) {
      const pagination = document.getElementById('pagination');
      pagination.innerHTML = '';
      const pageCount = Math.ceil(totalItems / ITEMS_PER_PAGE);
      if (pageCount <= 1) return;
      const fragment = document.createDocumentFragment();
      const prevBtn = document.createElement('button');
      prevBtn.textContent = 'Précédent';
      prevBtn.disabled = currentPage === 1;
      prevBtn.onclick = () => {
        if (currentPage > 1) {
          currentPage--;
          renderFiles(currentFiles, currentFolder);
          renderPagination(totalItems);
        }
      };
      fragment.appendChild(prevBtn);
      const nextBtn = document.createElement('button');
      nextBtn.textContent = 'Suivant';
      nextBtn.disabled = currentPage === pageCount;
      nextBtn.onclick = () => {
        if (currentPage < pageCount) {
          currentPage++;
          renderFiles(currentFiles, currentFolder);
          renderPagination(totalItems);
        }
      };
      fragment.appendChild(nextBtn);
      pagination.appendChild(fragment);
    }

    async function generateVideoThumbnail(video, fileId, fileSize) {
      if (fileSize > MAX_THUMBNAIL_SIZE) {
        console.log(`Fichier trop volumineux (${fileSize} octets), utilisation d'un placeholder`);
        return null;
      }
      const thumbnailData = await getThumbnail(fileId);
      if (thumbnailData) {
        const canvas = document.createElement('canvas');
        const img = new Image();
        img.src = thumbnailData;
        return new Promise((resolve) => {
          img.onload = () => {
            canvas.width = img.width;
            canvas.height = img.height;
            canvas.getContext('2d').drawImage(img, 0, 0);
            console.log(`Miniature chargée depuis cache pour ID ${fileId}`);
            resolve(canvas);
          };
          img.onerror = () => resolve(null);
        });
      }
      return new Promise((resolve) => {
        video.onloadedmetadata = () => {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = Math.min(video.videoWidth, 150);
          canvas.height = Math.min(video.videoHeight, 150 * (video.videoHeight / video.videoWidth));
          video.currentTime = 1;
          video.onseeked = () => {
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            const thumbnailData = canvas.toDataURL('image/jpeg', 0.6);
            saveThumbnail(fileId, thumbnailData);
            console.log(`Miniature générée pour ID ${fileId}`);
            resolve(canvas);
          };
          video.onerror = () => resolve(null);
        };
        video.onerror = () => resolve(null);
      });
    }

    async function renderFiles(files, folder) {
      const container = document.getElementById("filesContainer");
      container.innerHTML = `<h3><span class="material-icons">folder_open</span> Fichiers dans ${folder}</h3>`;
      const preview = document.createElement("div");
      preview.className = "preview";
      if (files.length === 0) {
        preview.innerHTML = "<p>Aucun fichier dans ce dossier. Ajoutez des images ou vidéos !</p>";
        container.appendChild(preview);
        return;
      }
      const start = (currentPage - 1) * ITEMS_PER_PAGE;
      const end = start + ITEMS_PER_PAGE;
      const paginatedFiles = files.slice(start, end);
      const fragment = document.createDocumentFragment();
      for (const file of paginatedFiles) {
        const wrapper = document.createElement('div');
        wrapper.style.display = 'inline-block';
        let element;
        if ((file.type || "").startsWith('image')) {
          element = document.createElement('img');
          element.dataset.src = file.data;
          element.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'; // Transparent placeholder
          element.loading = "lazy";
          element.onerror = () => {
            console.error(`Erreur de chargement de l'image: ${file.name || "sans nom"}`);
            element.replaceWith(document.createTextNode(`Erreur: ${file.name || "Image inconnue"}`));
          };
          element.onclick = () => showFullscreen(file, files.indexOf(file));
          wrapper.appendChild(element);
        } else {
          const video = document.createElement('video');
          video.src = file.data;
          element = await generateVideoThumbnail(video, file.id, file.size || 0);
          if (!element) {
            element = document.createElement('div');
            element.className = 'video-placeholder';
            element.innerHTML = `<span class="material-icons">movie</span> ${file.name || "Vidéo inconnue"}`;
          }
          element.onclick = () => showFullscreen(file, files.indexOf(file));
          wrapper.appendChild(element);
        }
        const delBtn = document.createElement('button');
        delBtn.innerHTML = '<span class="material-icons">delete</span> Supprimer';
        delBtn.className = 'file-actions-btn';
        delBtn.onclick = (e) => {
          e.stopPropagation();
          if (confirm("Voulez-vous vraiment supprimer ce fichier ?")) {
            deleteFile(file.id);
          }
        };
        const actionsDiv = document.createElement('div');
        actionsDiv.className = 'file-actions';
        actionsDiv.appendChild(delBtn);
        wrapper.appendChild(actionsDiv);
        fragment.appendChild(wrapper);
      }
      preview.appendChild(fragment);
      container.appendChild(preview);
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting && entry.target.tagName === 'IMG') {
            entry.target.src = entry.target.dataset.src;
          }
        });
      }, { rootMargin: '100px' });
      preview.querySelectorAll('img').forEach(img => observer.observe(img));
    }

    async function updateFolderSelect(folders) {
      const select = document.getElementById("folderSelect");
      const currentValue = select.value;
      const sortMethod = document.getElementById('sortSelect').value;
      if (sortMethod === 'recent') {
        const tx = db.transaction(STORE_NAME, "readonly");
        const store = tx.objectStore(STORE_NAME);
        const request = store.getAll();
        const data = await new Promise((resolve) => {
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => resolve([]);
        });
        const foldersMap = {};
        data.forEach(file => {
          if (!foldersMap[file.folder]) foldersMap[file.folder] = [];
          foldersMap[file.folder].push(file);
        });
        folders = Object.keys(foldersMap).sort((a, b) => {
          const latestA = Math.max(...foldersMap[a].map(f => f.created || 0));
          const latestB = Math.max(...foldersMap[b].map(f => f.created || 0));
          return latestB - latestA;
        });
      } else {
        folders.sort((a, b) => a.localeCompare(b, ['fr', 'tr'], { sensitivity: 'accent', ignorePunctuation: true }));
      }
      select.innerHTML = '<option disabled selected>-- Choisir un dossier --</option>';
      const fragment = document.createDocumentFragment();
      folders.forEach(f => {
        const opt = document.createElement('option');
        opt.value = f;
        opt.textContent = f;
        fragment.appendChild(opt);
      });
      select.appendChild(fragment);
      if (folders.includes(currentValue)) select.value = currentValue;
    }

    async function createFolder() {
      try {
        const name = document.getElementById('folderName').value.trim();
        if (!name) {
          showToast("Nom du dossier invalide.");
          return;
        }
        const select = document.getElementById('folderSelect');
        const exists = [...select.options].some(o => o.value.toLowerCase() === name.toLowerCase());
        if (exists) {
          showToast("Ce dossier existe déjà !");
          return;
        }
        const tx = db.transaction(STORE_NAME, "readwrite");
        const store = tx.objectStore(STORE_NAME);
        const fileRecord = {
          folder: name,
          name: `placeholder_${Date.now()}`,
          type: "text/plain",
          data: "data:text/plain;base64,",
          created: Date.now()
        };
        await new Promise((resolve, reject) => {
          const request = store.add(fileRecord);
          request.onsuccess = () => resolve();
          request.onerror = () => reject(new Error("Erreur lors de la création du dossier"));
        });
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        select.appendChild(opt);
        select.value = name;
        await loadFolders();
        document.getElementById('folderName').value = '';
        showToast("Dossier créé avec succès !");
      } catch (err) {
        console.error("Erreur dans createFolder:", err);
        showToast("Erreur lors de la création du dossier.");
      }
    }

    async function addFiles() {
      try {
        const folderName = document.getElementById('folderSelect').value;
        const files = document.getElementById('fileInput').files;
        if (!folderName || folderName === '-- Choisir un dossier --' || files.length === 0) {
          showToast("Sélectionnez un dossier et des fichiers");
          return;
        }
        showLoading(true);
        let processed = 0;
        const promises = [];
        for (const file of files) {
          if (!file.type.startsWith('image') && !file.type.startsWith('video')) {
            console.warn(`Fichier ignoré (type non supporté): ${file.name}`);
            processed++;
            continue;
          }
          promises.push(new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = async (e) => {
              try {
                await saveFile(folderName, file, e.target.result);
                resolve();
              } catch (err) {
                reject(err);
              }
            };
            reader.onerror = () => {
              console.error(`Erreur de lecture du fichier: ${file.name}`);
              showToast(`Erreur lors de la lecture de ${file.name}`);
              reject(new Error(`Erreur de lecture du fichier: ${file.name}`));
            };
            reader.readAsDataURL(file);
          }));
        }
        await Promise.allSettled(promises);
        document.getElementById('fileInput').value = '';
        await loadFolders();
        showLoading(false);
        showToast("Fichiers ajoutés avec succès !");
      } catch (err) {
        console.error("Erreur dans addFiles:", err);
        showLoading(false);
        showToast("Erreur lors de l'ajout des fichiers.");
      }
    }

    async function deleteFile(id) {
      try {
        showLoading(true);
        const tx = db.transaction([STORE_NAME, THUMBNAIL_STORE], "readwrite");
        const store = tx.objectStore(STORE_NAME);
        const thumbStore = tx.objectStore(THUMBNAIL_STORE);
        await Promise.all([
          new Promise((resolve, reject) => {
            const request = store.delete(id);
            request.onsuccess = () => resolve();
            request.onerror = () => reject(new Error("Erreur lors de la suppression du fichier"));
          }),
          new Promise((resolve, reject) => {
            const request = thumbStore.delete(id);
            request.onsuccess = () => resolve();
            request.onerror = () => resolve(); // Thumbnail deletion is optional
          })
        ]);
        console.log(`Fichier supprimé: ID ${id}`);
        const sortMethod = document.getElementById('sortSelect').value;
        if (currentFolder) await showFolderFiles(currentFolder, sortMethod);
        await loadFolders();
        showLoading(false);
        showToast("Fichier supprimé avec succès !");
      } catch (err) {
        console.error("Erreur dans deleteFile:", err);
        showLoading(false);
        showToast("Erreur lors de la suppression du fichier.");
      }
    }

    async function exportData() {
      try {
        showLoading(true);
        const tx = db.transaction(STORE_NAME, "readonly");
        const store = tx.objectStore(STORE_NAME);
        const request = store.getAll();
        const data = await new Promise((resolve, reject) => {
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(new Error("Erreur lors de l'exportation"));
        });
        const filteredData = data.filter(file => !file.name.startsWith('placeholder_'));
        const json = JSON.stringify(filteredData, null, 2);
        const blob = new Blob([json], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `filemanager_backup_${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        URL.revokeObjectURL(url);
        showLoading(false);
        showToast("Données exportées avec succès !");
      } catch (err) {
        console.error("Erreur dans exportData:", err);
        showLoading(false);
        showToast("Erreur lors de l'exportation.");
      }
    }

    async function importData(event) {
      try {
        const file = event.target.files[0];
        if (!file || !file.name.endsWith('.json')) {
          showToast("Veuillez sélectionner un fichier JSON valide.");
          return;
        }
        showLoading(true);
        const reader = new FileReader();
        const data = await new Promise((resolve, reject) => {
          reader.onload = (e) => resolve(JSON.parse(e.target.result));
          reader.onerror = () => reject(new Error("Erreur de lecture du fichier JSON"));
          reader.readAsText(file);
        });
        if (!Array.isArray(data)) throw new Error("Format JSON invalide");
        const tx = db.transaction(STORE_NAME, "readwrite");
        const store = tx.objectStore(STORE_NAME);
        let processed = 0;
        const promises = data.map(record => {
          if (record.folder && record.data) {
            return new Promise((resolve, reject) => {
              const request = store.put({ ...record, created: Date.now() });
              request.onsuccess = () => resolve();
              request.onerror = () => {
                console.warn("Enregistrement invalide ignoré:", record);
                resolve();
              };
            });
          }
          console.warn("Enregistrement invalide ignoré:", record);
          return Promise.resolve();
        });
        await Promise.all(promises);
        await loadFolders();
        showLoading(false);
        showToast("Données importées avec succès !");
        document.getElementById('importInput').value = '';
      } catch (err) {
        console.error("Erreur dans importData:", err);
        showLoading(false);
        showToast("Erreur lors de l'importation : " + err.message);
      }
    }

    async function showFullscreen(file, index) {
      try {
        currentFileIndex = index;
        const overlay = document.getElementById('fullscreenViewer');
        overlay.innerHTML = `
          <div class="nav-arrows">
            <button id="prevMedia" style="display: ${currentFileIndex > 0 ? 'block' : 'none'};">&larr;</button>
            <button id="nextMedia" style="display: ${currentFileIndex < currentFiles.length - 1 ? 'block' : 'none'};">&rarr;</button>
          </div>
          <button class="close-button" onclick="hideFullscreen()" aria-label="Fermer">
            <span class="material-icons">close</span>
          </button>`;
        let element;
        if ((file.type || "").startsWith('image')) {
          element = document.createElement('img');
          element.src = file.data;
          element.loading = "lazy";
          element.onerror = () => {
            console.error(`Erreur de chargement de l'image: ${file.name || "sans nom"}`);
            showToast(`Erreur de chargement de l'image: ${file.name || "Image inconnue"}`);
          };
        } else {
          const player = document.createElement('div');
          player.className = 'video-player';
          const video = document.createElement('video');
          video.src = file.data;
          video.setAttribute('playsinline', '');
          video.addEventListener('error', (e) => {
            console.error(`Erreur de chargement de la vidéo: ${file.name || "sans nom"}`, e);
            showToast(`Erreur de chargement de la vidéo: ${file.name || "Vidéo inconnue"}`);
          });
          player.appendChild(video);
          const controls = document.createElement('div');
          controls.className = 'video-controls';
          controls.innerHTML = `
            <button onclick="this.parentElement.parentElement.querySelector('video').paused ? this.parentElement.parentElement.querySelector('video').play() : this.parentElement.parentElement.querySelector('video').pause(); this.querySelector('span').textContent = this.parentElement.parentElement.querySelector('video').paused ? 'play_arrow' : 'pause';" aria-label="Lecture/Pause">
              <span class="material-icons">play_arrow</span>
            </button>
            <input type="range" min="0" max="100" value="0" class="progress" aria-label="Progression de la vidéo">
            <input type="range" min="0" max="1" step="0.1" value="1" class="volume" aria-label="Volume">
            <select class="speed" aria-label="Vitesse de lecture">
              <option value="0.5">0.5x</option>
              <option value="1" selected>1x</option>
              <option value="1.5">1.5x</option>
              <option value="2">2x</option>
            </select>
            <button onclick="if (document.fullscreenElement) document.exitFullscreen(); else this.parentElement.parentElement.querySelector('video').requestFullscreen();" aria-label="Plein écran">
              <span class="material-icons">fullscreen</span>
            </button>
          `;
          player.appendChild(controls);
          video.addEventListener('timeupdate', () => {
            const progress = controls.querySelector('.progress');
            progress.value = (video.currentTime / video.duration) * 100;
          });
          controls.querySelector('.progress').addEventListener('input', (e) => {
            video.currentTime = (e.target.value / 100) * video.duration;
          });
          controls.querySelector('.volume').addEventListener('input', (e) => {
            video.volume = e.target.value;
          });
          controls.querySelector('.speed').addEventListener('change', (e) => {
            video.playbackRate = parseFloat(e.target.value);
          });
          element = player;
        }
        overlay.appendChild(element);
        overlay.style.display = 'flex';
        document.getElementById('prevMedia').onclick = () => {
          if (currentFileIndex > 0) showFullscreen(currentFiles[currentFileIndex - 1], currentFileIndex - 1);
        };
        document.getElementById('nextMedia').onclick = () => {
          if (currentFileIndex < currentFiles.length - 1) showFullscreen(currentFiles[currentFileIndex + 1], currentFileIndex + 1);
        };
      } catch (err) {
        console.error("Erreur dans showFullscreen:", err);
        showToast("Erreur lors de l'affichage en plein écran.");
      }
    }

    function hideFullscreen() {
      try {
        const overlay = document.getElementById('fullscreenViewer');
        overlay.style.display = 'none';
        overlay.innerHTML = '<div class="nav-arrows"><button id="prevMedia" style="display: none;">&larr;</button><button id="nextMedia" style="display: none;">&rarr;</button></div>';
        currentFileIndex = -1;
      } catch (err) {
        console.error("Erreur dans hideFullscreen:", err);
        showToast("Erreur lors de la fermeture du plein écran.");
      }
    }

    function goBack() {
      try {
        currentFolder = null;
        currentPage = 1;
        loadFolders();
      } catch (err) {
        console.error("Erreur dans goBack:", err);
        showToast("Erreur lors du retour.");
      }
    }

    document.getElementById('fullscreenViewer').addEventListener('click', (event) => {
      if (event.target.classList.contains('close-button') || event.target.closest('.close-button')) return;
      if (event.target.id === 'prevMedia' || event.target.id === 'nextMedia') return;
      const rect = event.target.getBoundingClientRect();
      const clickX = event.clientX - rect.left;
      const width = rect.width;
      if (clickX < width / 2 && currentFileIndex > 0) {
        showFullscreen(currentFiles[currentFileIndex - 1], currentFileIndex - 1);
      } else if (clickX >= width / 2 && currentFileIndex < currentFiles.length - 1) {
        showFullscreen(currentFiles[currentFileIndex + 1], currentFileIndex + 1);
      }
    });
    document.getElementById('importInput').addEventListener('change', importData);
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') hideFullscreen();
    });

    window.onload = async () => {
      try {
        await openDB();
        await loadFolders();
      } catch (err) {
        console.error("Erreur au démarrage:", err);
        showToast("Erreur au démarrage de l'application.");
      }
    };
  </script>
</body>
</html>